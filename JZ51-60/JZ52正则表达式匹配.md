### JZ52正则表达式匹配
> 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

- 题目补充：本题只有叫我们分别实现`.`跟`*`的功能，并没有要实现`.*`（贪婪匹配），当遇到了`.*`只要看成`任意字符+\*`就好
- 思路：
	1. 使用递归方法递归函数`isMatch(i,j,s,p)`
		- i代表一个指向当前s中的字符的指针
		- j代表一个指向当前p中的字符的指针
		- s代表要匹配的字符串
		- p代表要匹配的正则字符串
	2. 首先要先确定边界
		- 当s跟p同时匹配结束的时候，无疑是返回true
		- 如果p结束了但是s还有，无疑返回false（因为不可能再匹配了）
		- 如果两个都还有，那就继续匹配
		- 如果s结束了但是p还没有，不能确定是true还是false，因为p有可能剩下"a\*a\*a\*"这种可能
	3. 本题的难点在于当下一个字符遇到`*`时要怎么处理，有2种可能
		- 如果当前s的字符匹配`*`前的字符或者`*`前的字符干脆就是`.`
		- 如果s当前字符与`*`前的字符不匹配
		- 知道了这个再分别处理就好（代码里有详细的注释）
- 思维导图：
![Alt](../剑指offer/img-ref-6.png)


```
//s, pattern都是字符串
function match(s, pattern)
{
    // write code here
    return isMatch(0,0,s,pattern);
    
}

//i代表当前比较的s的下标、j代表当前比较的p的下标
function isMatch(i,j,s,p){
    //当s跟p同时刚好配对结束
	if(s[i]==undefined && p[j]==undefined)
        return true;
    //当p配对结束了但是s还有
    if(s[i]!=undefined && p[j]==undefined)
        return false;
    //如果p当前字符的下一个不是"*"
    if(p[j+1]!="*"){
        //如果当前字符匹配或者遇到了万能匹配符"."
        if(s[i]==p[j] || (s[i]!=undefined && p[j]=="."))
    		return isMatch(i+1,j+1,s,p);
    	else
    		return false;
    }
    //如果p的当前字符的下一个是"*"
    else{
        //如果当前字符匹配或者遇到了万能匹配符"."
    	if(s[i]==p[j] || (s[i]!=undefined && p[j]=="."))
            //先试试看直接忽略"字符+*"的组合，如果不行，就一个个让他们匹配
    		return isMatch(i,j+2,s,p) || isMatch(i+1,j,s,p);
    	else
    		return isMatch(i,j+2,s,p);    //如果当前字符不匹配就直接忽略"字符+*"的组合
    }
}
```

